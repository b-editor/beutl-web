//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class AppClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : window as any;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7278";
  }

  checkForUpdates(version: string, signal?: AbortSignal | undefined): Promise<CheckForUpdatesResponse> {
    let url_ = this.baseUrl + "/api/v1/app/checkForUpdates/{version}";
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace("{version}", encodeURIComponent("" + version));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCheckForUpdates(_response);
    });
  }

  protected processCheckForUpdates(response: Response): Promise<CheckForUpdatesResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CheckForUpdatesResponse;
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<CheckForUpdatesResponse>(null as any);
  }

  sendLog(deviceId: string, file: FileParameter | undefined, signal?: AbortSignal | undefined): Promise<FileResponse | null> {
    let url_ = this.baseUrl + "/api/v1/app/sendLog/{deviceId}";
    if (deviceId === undefined || deviceId === null)
      throw new Error("The parameter 'deviceId' must be defined.");
    url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (file === null || file === undefined)
      throw new Error("The parameter 'file' cannot be null.");
    else
      content_.append("file", file.data, file.fileName ? file.fileName : "file");

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Accept": "application/octet-stream"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSendLog(_response);
    });
  }

  protected processSendLog(response: Response): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse | null>(null as any);
  }
}

export class AssetsClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : window as any;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7278";
  }

  getAsset(owner: string, name: string, signal?: AbortSignal | undefined): Promise<AssetMetadataResponse> {
    let url_ = this.baseUrl + "/api/v1/assets/{owner}/{name}";
    if (owner === undefined || owner === null)
      throw new Error("The parameter 'owner' must be defined.");
    url_ = url_.replace("{owner}", encodeURIComponent("" + owner));
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAsset(_response);
    });
  }

  protected processGetAsset(response: Response): Promise<AssetMetadataResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AssetMetadataResponse;
        return result200;
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null;
        result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<AssetMetadataResponse>(null as any);
  }

  post(owner: string, name: string, signal?: AbortSignal | undefined): Promise<AssetMetadataResponse> {
    let url_ = this.baseUrl + "/api/v1/assets/{owner}/{name}";
    if (owner === undefined || owner === null)
      throw new Error("The parameter 'owner' must be defined.");
    url_ = url_.replace("{owner}", encodeURIComponent("" + owner));
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPost(_response);
    });
  }

  protected processPost(response: Response): Promise<AssetMetadataResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AssetMetadataResponse;
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null;
        result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      });
    } else if (status === 415) {
      return response.text().then((_responseText) => {
        return throwException("A server side error occurred.", status, _responseText, _headers);
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      });
    } else if (status === 409) {
      return response.text().then((_responseText) => {
        let result409: any = null;
        result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result409);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<AssetMetadataResponse>(null as any);
  }

  patch(owner: string, name: string, request: UpdateAssetRequest, signal?: AbortSignal | undefined): Promise<AssetMetadataResponse> {
    let url_ = this.baseUrl + "/api/v1/assets/{owner}/{name}";
    if (owner === undefined || owner === null)
      throw new Error("The parameter 'owner' must be defined.");
    url_ = url_.replace("{owner}", encodeURIComponent("" + owner));
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "PATCH",
      signal,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPatch(_response);
    });
  }

  protected processPatch(response: Response): Promise<AssetMetadataResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AssetMetadataResponse;
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null;
        result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<AssetMetadataResponse>(null as any);
  }

  delete(owner: string, name: string, signal?: AbortSignal | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/v1/assets/{owner}/{name}";
    if (owner === undefined || owner === null)
      throw new Error("The parameter 'owner' must be defined.");
    url_ = url_.replace("{owner}", encodeURIComponent("" + owner));
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "DELETE",
      signal,
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDelete(_response);
    });
  }

  protected processDelete(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null;
        result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      });
    } else if (status === 423) {
      return response.text().then((_responseText) => {
        let result423: any = null;
        result423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result423);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  downloadAsset(owner: string, name: string, signal?: AbortSignal | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/v1/assets/{owner}/{name}/download";
    if (owner === undefined || owner === null)
      throw new Error("The parameter 'owner' must be defined.");
    url_ = url_.replace("{owner}", encodeURIComponent("" + owner));
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDownloadAsset(_response);
    });
  }

  protected processDownloadAsset(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null;
        result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  getAsset2(id: number, signal?: AbortSignal | undefined): Promise<AssetMetadataResponse> {
    let url_ = this.baseUrl + "/api/v1/assets/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAsset2(_response);
    });
  }

  protected processGetAsset2(response: Response): Promise<AssetMetadataResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AssetMetadataResponse;
        return result200;
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null;
        result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<AssetMetadataResponse>(null as any);
  }
}

export class DiscoverClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : window as any;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7278";
  }

  searchUsers(query: string | undefined, start: number | undefined, count: number | undefined, signal?: AbortSignal | undefined): Promise<SimpleProfileResponse[]> {
    let url_ = this.baseUrl + "/api/v1/discover/users/search?";
    if (query === null)
      throw new Error("The parameter 'query' cannot be null.");
    else if (query !== undefined)
      url_ += "query=" + encodeURIComponent("" + query) + "&";
    if (start === null)
      throw new Error("The parameter 'start' cannot be null.");
    else if (start !== undefined)
      url_ += "start=" + encodeURIComponent("" + start) + "&";
    if (count === null)
      throw new Error("The parameter 'count' cannot be null.");
    else if (count !== undefined)
      url_ += "count=" + encodeURIComponent("" + count) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSearchUsers(_response);
    });
  }

  protected processSearchUsers(response: Response): Promise<SimpleProfileResponse[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SimpleProfileResponse[];
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SimpleProfileResponse[]>(null as any);
  }

  searchPackages(query: string | undefined, start: number | undefined, count: number | undefined, signal?: AbortSignal | undefined): Promise<SimplePackageResponse[]> {
    let url_ = this.baseUrl + "/api/v1/discover/packages/search?";
    if (query === null)
      throw new Error("The parameter 'query' cannot be null.");
    else if (query !== undefined)
      url_ += "query=" + encodeURIComponent("" + query) + "&";
    if (start === null)
      throw new Error("The parameter 'start' cannot be null.");
    else if (start !== undefined)
      url_ += "start=" + encodeURIComponent("" + start) + "&";
    if (count === null)
      throw new Error("The parameter 'count' cannot be null.");
    else if (count !== undefined)
      url_ += "count=" + encodeURIComponent("" + count) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSearchPackages(_response);
    });
  }

  protected processSearchPackages(response: Response): Promise<SimplePackageResponse[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SimplePackageResponse[];
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SimplePackageResponse[]>(null as any);
  }

  search(query: string | undefined, start: number | undefined, count: number | undefined, signal?: AbortSignal | undefined): Promise<SimplePackageResponse[]> {
    let url_ = this.baseUrl + "/api/v1/discover/search?";
    if (query === null)
      throw new Error("The parameter 'query' cannot be null.");
    else if (query !== undefined)
      url_ += "query=" + encodeURIComponent("" + query) + "&";
    if (start === null)
      throw new Error("The parameter 'start' cannot be null.");
    else if (start !== undefined)
      url_ += "start=" + encodeURIComponent("" + start) + "&";
    if (count === null)
      throw new Error("The parameter 'count' cannot be null.");
    else if (count !== undefined)
      url_ += "count=" + encodeURIComponent("" + count) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSearch(_response);
    });
  }

  protected processSearch(response: Response): Promise<SimplePackageResponse[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SimplePackageResponse[];
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SimplePackageResponse[]>(null as any);
  }

  getDaily(start: number | undefined, count: number | undefined, signal?: AbortSignal | undefined): Promise<SimplePackageResponse[]> {
    let url_ = this.baseUrl + "/api/v1/discover/daily?";
    if (start === null)
      throw new Error("The parameter 'start' cannot be null.");
    else if (start !== undefined)
      url_ += "start=" + encodeURIComponent("" + start) + "&";
    if (count === null)
      throw new Error("The parameter 'count' cannot be null.");
    else if (count !== undefined)
      url_ += "count=" + encodeURIComponent("" + count) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetDaily(_response);
    });
  }

  protected processGetDaily(response: Response): Promise<SimplePackageResponse[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SimplePackageResponse[];
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SimplePackageResponse[]>(null as any);
  }

  getWeekly(start: number | undefined, count: number | undefined, signal?: AbortSignal | undefined): Promise<SimplePackageResponse[]> {
    let url_ = this.baseUrl + "/api/v1/discover/weekly?";
    if (start === null)
      throw new Error("The parameter 'start' cannot be null.");
    else if (start !== undefined)
      url_ += "start=" + encodeURIComponent("" + start) + "&";
    if (count === null)
      throw new Error("The parameter 'count' cannot be null.");
    else if (count !== undefined)
      url_ += "count=" + encodeURIComponent("" + count) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetWeekly(_response);
    });
  }

  protected processGetWeekly(response: Response): Promise<SimplePackageResponse[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SimplePackageResponse[];
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SimplePackageResponse[]>(null as any);
  }

  getOverall(start: number | undefined, count: number | undefined, signal?: AbortSignal | undefined): Promise<SimplePackageResponse[]> {
    let url_ = this.baseUrl + "/api/v1/discover/overall?";
    if (start === null)
      throw new Error("The parameter 'start' cannot be null.");
    else if (start !== undefined)
      url_ += "start=" + encodeURIComponent("" + start) + "&";
    if (count === null)
      throw new Error("The parameter 'count' cannot be null.");
    else if (count !== undefined)
      url_ += "count=" + encodeURIComponent("" + count) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetOverall(_response);
    });
  }

  protected processGetOverall(response: Response): Promise<SimplePackageResponse[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SimplePackageResponse[];
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SimplePackageResponse[]>(null as any);
  }

  getRecently(start: number | undefined, count: number | undefined, signal?: AbortSignal | undefined): Promise<SimplePackageResponse[]> {
    let url_ = this.baseUrl + "/api/v1/discover/recently?";
    if (start === null)
      throw new Error("The parameter 'start' cannot be null.");
    else if (start !== undefined)
      url_ += "start=" + encodeURIComponent("" + start) + "&";
    if (count === null)
      throw new Error("The parameter 'count' cannot be null.");
    else if (count !== undefined)
      url_ += "count=" + encodeURIComponent("" + count) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetRecently(_response);
    });
  }

  protected processGetRecently(response: Response): Promise<SimplePackageResponse[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SimplePackageResponse[];
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SimplePackageResponse[]>(null as any);
  }

  /**
   * @deprecated
   */
  updateSearchIndex(signal?: AbortSignal | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/v1/discover/updateSearchIndex";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      signal,
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateSearchIndex(_response);
    });
  }

  protected processUpdateSearchIndex(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }
}

export class PackagesClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : window as any;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7278";
  }

  getPackage(name: string, signal?: AbortSignal | undefined): Promise<PackageResponse> {
    let url_ = this.baseUrl + "/api/v1/packages/{name}";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetPackage(_response);
    });
  }

  protected processGetPackage(response: Response): Promise<PackageResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PackageResponse;
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null;
        result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<PackageResponse>(null as any);
  }

  patch(name: string, request: UpdatePackageRequest, signal?: AbortSignal | undefined): Promise<PackageResponse> {
    let url_ = this.baseUrl + "/api/v1/packages/{name}";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "PATCH",
      signal,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPatch(_response);
    });
  }

  protected processPatch(response: Response): Promise<PackageResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PackageResponse;
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null;
        result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      });
    } else if (status === 409) {
      return response.text().then((_responseText) => {
        let result409: any = null;
        result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result409);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<PackageResponse>(null as any);
  }

  post(name: string, request: CreatePackageRequest, signal?: AbortSignal | undefined): Promise<PackageResponse> {
    let url_ = this.baseUrl + "/api/v1/packages/{name}";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPost(_response);
    });
  }

  protected processPost(response: Response): Promise<PackageResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PackageResponse;
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null;
        result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      });
    } else if (status === 409) {
      return response.text().then((_responseText) => {
        let result409: any = null;
        result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result409);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<PackageResponse>(null as any);
  }

  delete(name: string, signal?: AbortSignal | undefined): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/v1/packages/{name}";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "DELETE",
      signal,
      headers: {
        "Accept": "application/octet-stream"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDelete(_response);
    });
  }

  protected processDelete(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null;
        result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }
}

export class ReleasesClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : window as any;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7278";
  }

  getReleases(name: string, start: number | undefined, count: number | undefined, signal?: AbortSignal | undefined): Promise<ReleaseResponse[]> {
    let url_ = this.baseUrl + "/api/v1/packages/{name}/releases?";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    if (start === null)
      throw new Error("The parameter 'start' cannot be null.");
    else if (start !== undefined)
      url_ += "start=" + encodeURIComponent("" + start) + "&";
    if (count === null)
      throw new Error("The parameter 'count' cannot be null.");
    else if (count !== undefined)
      url_ += "count=" + encodeURIComponent("" + count) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetReleases(_response);
    });
  }

  protected processGetReleases(response: Response): Promise<ReleaseResponse[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ReleaseResponse[];
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null;
        result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ReleaseResponse[]>(null as any);
  }

  getRelease(name: string, version: string, signal?: AbortSignal | undefined): Promise<ReleaseResponse> {
    let url_ = this.baseUrl + "/api/v1/packages/{name}/releases/{version}";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace("{version}", encodeURIComponent("" + version));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetRelease(_response);
    });
  }

  protected processGetRelease(response: Response): Promise<ReleaseResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ReleaseResponse;
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null;
        result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ReleaseResponse>(null as any);
  }

  patch(name: string, version: string, request: UpdateReleaseRequest, signal?: AbortSignal | undefined): Promise<ReleaseResponse> {
    let url_ = this.baseUrl + "/api/v1/packages/{name}/releases/{version}";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace("{version}", encodeURIComponent("" + version));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "PATCH",
      signal,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPatch(_response);
    });
  }

  protected processPatch(response: Response): Promise<ReleaseResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ReleaseResponse;
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null;
        result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ReleaseResponse>(null as any);
  }

  post(name: string, version: string, request: CreateReleaseRequest, signal?: AbortSignal | undefined): Promise<ReleaseResponse> {
    let url_ = this.baseUrl + "/api/v1/packages/{name}/releases/{version}";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace("{version}", encodeURIComponent("" + version));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPost(_response);
    });
  }

  protected processPost(response: Response): Promise<ReleaseResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ReleaseResponse;
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null;
        result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      });
    } else if (status === 409) {
      return response.text().then((_responseText) => {
        let result409: any = null;
        result409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result409);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ReleaseResponse>(null as any);
  }

  delete(name: string, version: string, signal?: AbortSignal | undefined): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/v1/packages/{name}/releases/{version}";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace("{version}", encodeURIComponent("" + version));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "DELETE",
      signal,
      headers: {
        "Accept": "application/octet-stream"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDelete(_response);
    });
  }

  protected processDelete(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null;
        result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }
}

export class UsersClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : window as any;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7278";
  }

  getUser(name: string, signal?: AbortSignal | undefined): Promise<ProfileResponse> {
    let url_ = this.baseUrl + "/api/v1/users/{name}";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetUser(_response);
    });
  }

  protected processGetUser(response: Response): Promise<ProfileResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProfileResponse;
        return result200;
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ProfileResponse>(null as any);
  }

  patch(name: string, request: UpdateProfileRequest, signal?: AbortSignal | undefined): Promise<ProfileResponse> {
    let url_ = this.baseUrl + "/api/v1/users/{name}";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "PATCH",
      signal,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPatch(_response);
    });
  }

  protected processPatch(response: Response): Promise<ProfileResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProfileResponse;
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null;
        result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdentityError[];
        return throwException("A server side error occurred.", status, _responseText, _headers, result500);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ProfileResponse>(null as any);
  }

  get(start: number | undefined, count: number | undefined, signal?: AbortSignal | undefined): Promise<SimpleProfileResponse[]> {
    let url_ = this.baseUrl + "/api/v1/users?";
    if (start === null)
      throw new Error("The parameter 'start' cannot be null.");
    else if (start !== undefined)
      url_ += "start=" + encodeURIComponent("" + start) + "&";
    if (count === null)
      throw new Error("The parameter 'count' cannot be null.");
    else if (count !== undefined)
      url_ += "count=" + encodeURIComponent("" + count) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGet(_response);
    });
  }

  protected processGet(response: Response): Promise<SimpleProfileResponse[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SimpleProfileResponse[];
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SimpleProfileResponse[]>(null as any);
  }

  getPackages(name: string, start: number | undefined, count: number | undefined, signal?: AbortSignal | undefined): Promise<SimplePackageResponse[]> {
    let url_ = this.baseUrl + "/api/v1/users/{name}/packages?";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    if (start === null)
      throw new Error("The parameter 'start' cannot be null.");
    else if (start !== undefined)
      url_ += "start=" + encodeURIComponent("" + start) + "&";
    if (count === null)
      throw new Error("The parameter 'count' cannot be null.");
    else if (count !== undefined)
      url_ += "count=" + encodeURIComponent("" + count) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetPackages(_response);
    });
  }

  protected processGetPackages(response: Response): Promise<SimplePackageResponse[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SimplePackageResponse[];
        return result200;
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SimplePackageResponse[]>(null as any);
  }

  get2(signal?: AbortSignal | undefined): Promise<ProfileResponse> {
    let url_ = this.baseUrl + "/api/v1/user";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGet2(_response);
    });
  }

  protected processGet2(response: Response): Promise<ProfileResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProfileResponse;
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ProfileResponse>(null as any);
  }

  patch2(request: UpdateProfileRequest, signal?: AbortSignal | undefined): Promise<ProfileResponse> {
    let url_ = this.baseUrl + "/api/v1/user";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "PATCH",
      signal,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPatch2(_response);
    });
  }

  protected processPatch2(response: Response): Promise<ProfileResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProfileResponse;
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null;
        result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      });
    } else if (status === 500) {
      return response.text().then((_responseText) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdentityError[];
        return throwException("A server side error occurred.", status, _responseText, _headers, result500);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ProfileResponse>(null as any);
  }

  getAssets(name: string, start: number | undefined, count: number | undefined, signal?: AbortSignal | undefined): Promise<AssetMetadataResponse[]> {
    let url_ = this.baseUrl + "/api/v1/users/{name}/assets?";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    if (start === null)
      throw new Error("The parameter 'start' cannot be null.");
    else if (start !== undefined)
      url_ += "start=" + encodeURIComponent("" + start) + "&";
    if (count === null)
      throw new Error("The parameter 'count' cannot be null.");
    else if (count !== undefined)
      url_ += "count=" + encodeURIComponent("" + count) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetAssets(_response);
    });
  }

  protected processGetAssets(response: Response): Promise<AssetMetadataResponse[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AssetMetadataResponse[];
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null;
        result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<AssetMetadataResponse[]>(null as any);
  }
}

export class AccountClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : window as any;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7278";
  }

  storageUsage(signal?: AbortSignal | undefined): Promise<StorageUsageResponse> {
    let url_ = this.baseUrl + "/api/v1/account/storageUsage";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processStorageUsage(_response);
    });
  }

  protected processStorageUsage(response: Response): Promise<StorageUsageResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StorageUsageResponse;
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FileResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<StorageUsageResponse>(null as any);
  }

  handler(identifier: string | undefined, signal?: AbortSignal | undefined): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/v1/account/handler?";
    if (identifier === null)
      throw new Error("The parameter 'identifier' cannot be null.");
    else if (identifier !== undefined)
      url_ += "identifier=" + encodeURIComponent("" + identifier) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/octet-stream"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processHandler(_response);
    });
  }

  protected processHandler(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FileResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FileResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }

  createAuthUri(request: CreateAuthUriRequest, signal?: AbortSignal | undefined): Promise<CreateAuthUriResponse> {
    let url_ = this.baseUrl + "/api/v1/account/createAuthUri";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCreateAuthUri(_response);
    });
  }

  protected processCreateAuthUri(response: Response): Promise<CreateAuthUriResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CreateAuthUriResponse;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<CreateAuthUriResponse>(null as any);
  }

  refresh(request: RefeshTokenRequest, signal?: AbortSignal | undefined): Promise<AuthResponse> {
    let url_ = this.baseUrl + "/api/v1/account/refresh";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRefresh(_response);
    });
  }

  protected processRefresh(response: Response): Promise<AuthResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AuthResponse;
        return result200;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FileResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<AuthResponse>(null as any);
  }

  codeToJwt(request: CodeToJwtRequest, signal?: AbortSignal | undefined): Promise<AuthResponse> {
    let url_ = this.baseUrl + "/api/v1/account/code2jwt";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCodeToJwt(_response);
    });
  }

  protected processCodeToJwt(response: Response): Promise<AuthResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AuthResponse;
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as FileResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<AuthResponse>(null as any);
  }
}

export class LibraryClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : window as any;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7278";
  }

  getPackage(request: GetPackageRequest, signal?: AbortSignal | undefined): Promise<GotPackageResponse> {
    let url_ = this.baseUrl + "/api/v1/account/library";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetPackage(_response);
    });
  }

  protected processGetPackage(response: Response): Promise<GotPackageResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GotPackageResponse;
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 403) {
      return response.text().then((_responseText) => {
        let result403: any = null;
        result403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<GotPackageResponse>(null as any);
  }

  getLibrary(start: number | undefined, count: number | undefined, signal?: AbortSignal | undefined): Promise<GotPackageResponse[]> {
    let url_ = this.baseUrl + "/api/v1/account/library?";
    if (start === null)
      throw new Error("The parameter 'start' cannot be null.");
    else if (start !== undefined)
      url_ += "start=" + encodeURIComponent("" + start) + "&";
    if (count === null)
      throw new Error("The parameter 'count' cannot be null.");
    else if (count !== undefined)
      url_ += "count=" + encodeURIComponent("" + count) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetLibrary(_response);
    });
  }

  protected processGetLibrary(response: Response): Promise<GotPackageResponse[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GotPackageResponse[];
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<GotPackageResponse[]>(null as any);
  }

  deletePackage(name: string, signal?: AbortSignal | undefined): Promise<FileResponse> {
    let url_ = this.baseUrl + "/api/v1/account/library/{name}";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "DELETE",
      signal,
      headers: {
        "Accept": "application/octet-stream"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDeletePackage(_response);
    });
  }

  protected processDeletePackage(response: Response): Promise<FileResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse>(null as any);
  }
}

export class Fido2Client {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : window as any;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7278";
  }

  postAttestationOptions(signal?: AbortSignal | undefined): Promise<CredentialCreateOptions> {
    let url_ = this.baseUrl + "/api/v2/identity/fido2/attestation/options";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostAttestationOptions(_response);
    });
  }

  protected processPostAttestationOptions(response: Response): Promise<CredentialCreateOptions> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CredentialCreateOptions;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<CredentialCreateOptions>(null as any);
  }

  postAttestationResult(attestationResponse: AuthenticatorAttestationRawResponse, signal?: AbortSignal | undefined): Promise<CredentialMakeResult> {
    let url_ = this.baseUrl + "/api/v2/identity/fido2/attestation/result";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(attestationResponse);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostAttestationResult(_response);
    });
  }

  protected processPostAttestationResult(response: Response): Promise<CredentialMakeResult> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CredentialMakeResult;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<CredentialMakeResult>(null as any);
  }

  postAssertionOptions(signal?: AbortSignal | undefined): Promise<AssertionOptions> {
    let url_ = this.baseUrl + "/api/v2/identity/fido2/assertion/options";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostAssertionOptions(_response);
    });
  }

  protected processPostAssertionOptions(response: Response): Promise<AssertionOptions> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AssertionOptions;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<AssertionOptions>(null as any);
  }

  postAssertionResult(clientResponse: AuthenticatorAssertionRawResponse, signal?: AbortSignal | undefined): Promise<VerifyAssertionResult> {
    let url_ = this.baseUrl + "/api/v2/identity/fido2/assertion/result";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(clientResponse);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processPostAssertionResult(_response);
    });
  }

  protected processPostAssertionResult(response: Response): Promise<VerifyAssertionResult> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VerifyAssertionResult;
        return result200;
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<VerifyAssertionResult>(null as any);
  }

  getCredentials(signal?: AbortSignal | undefined): Promise<Fido2CredentialResponse[]> {
    let url_ = this.baseUrl + "/api/v2/identity/fido2/credentials";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetCredentials(_response);
    });
  }

  protected processGetCredentials(response: Response): Promise<Fido2CredentialResponse[]> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Fido2CredentialResponse[];
        return result200;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Fido2CredentialResponse[]>(null as any);
  }

  deleteCredential(id: string, signal?: AbortSignal | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/v2/identity/fido2/credentials/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "DELETE",
      signal,
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDeleteCredential(_response);
    });
  }

  protected processDeleteCredential(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  updateCredential(id: string, request: UpdateFido2CredentialRequest, signal?: AbortSignal | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/v2/identity/fido2/credentials/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "PATCH",
      signal,
      headers: {
        "Content-Type": "application/json",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateCredential(_response);
    });
  }

  protected processUpdateCredential(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 404) {
      return response.text().then((_responseText) => {
        return throwException("A server side error occurred.", status, _responseText, _headers);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }
}

export class IdentityClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : window as any;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7278";
  }

  signIn(request: SignInRequest, signal?: AbortSignal | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/v2/identity/signIn";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSignIn(_response);
    });
  }

  protected processSignIn(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      });
    } else if (status === 423) {
      return response.text().then((_responseText) => {
        let result423: any = null;
        result423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result423);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  signInWith2fa(request: SignInWith2faRequest, remember: boolean | undefined, signal?: AbortSignal | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/v2/identity/signInWith2fa?";
    if (remember === null)
      throw new Error("The parameter 'remember' cannot be null.");
    else if (remember !== undefined)
      url_ += "remember=" + encodeURIComponent("" + remember) + "&";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSignInWith2fa(_response);
    });
  }

  protected processSignInWith2fa(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      });
    } else if (status === 423) {
      return response.text().then((_responseText) => {
        let result423: any = null;
        result423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result423);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  signInWithRecoveryCode(request: SignInWithRecoveryCodeRequest, signal?: AbortSignal | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/v2/identity/signInWithRecoveryCode";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSignInWithRecoveryCode(_response);
    });
  }

  protected processSignInWithRecoveryCode(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      });
    } else if (status === 423) {
      return response.text().then((_responseText) => {
        let result423: any = null;
        result423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result423);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  signInWith(provider: string | undefined, returnUrl: string | null | undefined, signal?: AbortSignal | undefined): Promise<FileResponse | null> {
    let url_ = this.baseUrl + "/api/v2/identity/signInWith";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (provider === null || provider === undefined)
      throw new Error("The parameter 'provider' cannot be null.");
    else
      content_.append("provider", provider.toString());
    if (returnUrl !== null && returnUrl !== undefined)
      content_.append("returnUrl", returnUrl.toString());

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Accept": "application/octet-stream"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSignInWith(_response);
    });
  }

  protected processSignInWith(response: Response): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse | null>(null as any);
  }

  signInWithCallback(signal?: AbortSignal | undefined): Promise<SignInWithResponse> {
    let url_ = this.baseUrl + "/api/v2/identity/signInWith/callback";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSignInWithCallback(_response);
    });
  }

  protected processSignInWithCallback(response: Response): Promise<SignInWithResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 423) {
      return response.text().then((_responseText) => {
        let result423: any = null;
        result423 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result423);
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SignInWithResponse;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SignInWithResponse>(null as any);
  }

  signInWithConfirmation(request: SignInWithConfirmationRequest, signal?: AbortSignal | undefined): Promise<SignInWithResponse> {
    let url_ = this.baseUrl + "/api/v2/identity/signInWith/confirmation";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSignInWithConfirmation(_response);
    });
  }

  protected processSignInWithConfirmation(response: Response): Promise<SignInWithResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SignInWithResponse;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<SignInWithResponse>(null as any);
  }

  signOut(signal?: AbortSignal | undefined): Promise<FileResponse | null> {
    let url_ = this.baseUrl + "/api/v2/identity/signOut";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      signal,
      headers: {
        "Accept": "application/octet-stream"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSignOut(_response);
    });
  }

  protected processSignOut(response: Response): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse | null>(null as any);
  }

  signUp(request: SignUpRequest, signal?: AbortSignal | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/v2/identity/signUp";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSignUp(_response);
    });
  }

  protected processSignUp(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  checkEmail(request: CheckEmailRequest, signal?: AbortSignal | undefined): Promise<CheckEmailResponse> {
    let url_ = this.baseUrl + "/api/v2/identity/checkEmail";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processCheckEmail(_response);
    });
  }

  protected processCheckEmail(response: Response): Promise<CheckEmailResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CheckEmailResponse;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<CheckEmailResponse>(null as any);
  }

  confirmEmail(request: ConfirmEmailRequest, signal?: AbortSignal | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/v2/identity/confirmEmail";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConfirmEmail(_response);
    });
  }

  protected processConfirmEmail(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      });
    } else if (status === 422) {
      return response.text().then((_responseText) => {
        let result422: any = null;
        result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result422);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  confirmEmailChange(request: ConfirmEmailChangeRequest, signal?: AbortSignal | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/v2/identity/confirmEmailChange";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConfirmEmailChange(_response);
    });
  }

  protected processConfirmEmailChange(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      });
    } else if (status === 422) {
      return response.text().then((_responseText) => {
        let result422: any = null;
        result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result422);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  sendVerificationEmail(signal?: AbortSignal | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/v2/identity/sendVerificationEmail";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      signal,
      headers: {
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSendVerificationEmail(_response);
    });
  }

  protected processSendVerificationEmail(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 404) {
      return response.text().then((_responseText) => {
        let result404: any = null;
        result404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  isAuthenticated(signal?: AbortSignal | undefined): Promise<IsAuthenticatedResponse> {
    let url_ = this.baseUrl + "/api/v2/identity/isAuthenticated";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processIsAuthenticated(_response);
    });
  }

  protected processIsAuthenticated(response: Response): Promise<IsAuthenticatedResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IsAuthenticatedResponse;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<IsAuthenticatedResponse>(null as any);
  }

  getIdentity(signal?: AbortSignal | undefined): Promise<IdentityResponse> {
    let url_ = this.baseUrl + "/api/v2/identity";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetIdentity(_response);
    });
  }

  protected processGetIdentity(response: Response): Promise<IdentityResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IdentityResponse;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<IdentityResponse>(null as any);
  }

  updateUserName(request: UpdateUserNameRequest, signal?: AbortSignal | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/v2/identity/updateUserName";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateUserName(_response);
    });
  }

  protected processUpdateUserName(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 422) {
      return response.text().then((_responseText) => {
        let result422: any = null;
        result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result422);
      });
    } else if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  updateEmail(request: UpdateEmailRequest, signal?: AbortSignal | undefined): Promise<string> {
    let url_ = this.baseUrl + "/api/v2/identity/updateEmail";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processUpdateEmail(_response);
    });
  }

  protected processUpdateEmail(response: Response): Promise<string> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<string>(null as any);
  }

  forgotPassword(request: ForgotPasswordRequest, signal?: AbortSignal | undefined): Promise<FileResponse | null> {
    let url_ = this.baseUrl + "/api/v2/identity/forgotPassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processForgotPassword(_response);
    });
  }

  protected processForgotPassword(response: Response): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse | null>(null as any);
  }

  resetPassword(request: ResetPasswordRequest, signal?: AbortSignal | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/v2/identity/resetPassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processResetPassword(_response);
    });
  }

  protected processResetPassword(response: Response): Promise<void> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        return;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<void>(null as any);
  }

  setPassword(request: SetPasswordRequest, signal?: AbortSignal | undefined): Promise<string> {
    let url_ = this.baseUrl + "/api/v2/identity/setPassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processSetPassword(_response);
    });
  }

  protected processSetPassword(response: Response): Promise<string> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<string>(null as any);
  }

  changePassword(request: ChangePasswordRequest, signal?: AbortSignal | undefined): Promise<string> {
    let url_ = this.baseUrl + "/api/v2/identity/changePassword";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processChangePassword(_response);
    });
  }

  protected processChangePassword(response: Response): Promise<string> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<string>(null as any);
  }

  hasPassword(signal?: AbortSignal | undefined): Promise<boolean> {
    let url_ = this.baseUrl + "/api/v2/identity/hasPassword";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processHasPassword(_response);
    });
  }

  protected processHasPassword(response: Response): Promise<boolean> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<boolean>(null as any);
  }

  getExternalAccounts(signal?: AbortSignal | undefined): Promise<ExternalAccountsResponse> {
    let url_ = this.baseUrl + "/api/v2/identity/externalAccounts";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetExternalAccounts(_response);
    });
  }

  protected processGetExternalAccounts(response: Response): Promise<ExternalAccountsResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ExternalAccountsResponse;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<ExternalAccountsResponse>(null as any);
  }

  removeExternalAccount(provider: string, signal?: AbortSignal | undefined): Promise<RemoveExternalAccountResponse> {
    let url_ = this.baseUrl + "/api/v2/identity/externalAccounts/{provider}";
    if (provider === undefined || provider === null)
      throw new Error("The parameter 'provider' must be defined.");
    url_ = url_.replace("{provider}", encodeURIComponent("" + provider));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "DELETE",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processRemoveExternalAccount(_response);
    });
  }

  protected processRemoveExternalAccount(response: Response): Promise<RemoveExternalAccountResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 422) {
      return response.text().then((_responseText) => {
        let result422: any = null;
        result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result422);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RemoveExternalAccountResponse;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<RemoveExternalAccountResponse>(null as any);
  }

  linkExternalAccount(provider: string, signal?: AbortSignal | undefined): Promise<FileResponse | null> {
    let url_ = this.baseUrl + "/api/v2/identity/externalAccounts/{provider}";
    if (provider === undefined || provider === null)
      throw new Error("The parameter 'provider' must be defined.");
    url_ = url_.replace("{provider}", encodeURIComponent("" + provider));
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      signal,
      headers: {
        "Accept": "application/octet-stream"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLinkExternalAccount(_response);
    });
  }

  protected processLinkExternalAccount(response: Response): Promise<FileResponse | null> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<FileResponse | null>(null as any);
  }

  linkExternalAccountCallback(signal?: AbortSignal | undefined): Promise<LinkExternalAccountResponse> {
    let url_ = this.baseUrl + "/api/v2/identity/externalAccountsCallback";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processLinkExternalAccountCallback(_response);
    });
  }

  protected processLinkExternalAccountCallback(response: Response): Promise<LinkExternalAccountResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 422) {
      return response.text().then((_responseText) => {
        let result422: any = null;
        result422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result422);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LinkExternalAccountResponse;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<LinkExternalAccountResponse>(null as any);
  }

  deleteAccount(request: DeleteAccountRequest, signal?: AbortSignal | undefined): Promise<DeleteAccountResponse> {
    let url_ = this.baseUrl + "/api/v2/identity/deleteAccount";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDeleteAccount(_response);
    });
  }

  protected processDeleteAccount(response: Response): Promise<DeleteAccountResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DeleteAccountResponse;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<DeleteAccountResponse>(null as any);
  }
}

export class TwoFactorAuthenticationClient {
  private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
    this.http = http ? http : window as any;
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "https://localhost:7278";
  }

  getTwoFactorAuthentication(signal?: AbortSignal | undefined): Promise<TwoFactorAuthenticationResponse> {
    let url_ = this.baseUrl + "/api/v2/identity/2fa";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "GET",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGetTwoFactorAuthentication(_response);
    });
  }

  protected processGetTwoFactorAuthentication(response: Response): Promise<TwoFactorAuthenticationResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TwoFactorAuthenticationResponse;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<TwoFactorAuthenticationResponse>(null as any);
  }

  forgetThisBrowser(signal?: AbortSignal | undefined): Promise<string> {
    let url_ = this.baseUrl + "/api/v2/identity/2fa/forget";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processForgetThisBrowser(_response);
    });
  }

  protected processForgetThisBrowser(response: Response): Promise<string> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<string>(null as any);
  }

  disable2fa(signal?: AbortSignal | undefined): Promise<string> {
    let url_ = this.baseUrl + "/api/v2/identity/2fa/disable";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processDisable2fa(_response);
    });
  }

  protected processDisable2fa(response: Response): Promise<string> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<string>(null as any);
  }

  generateRecoveryCodes(signal?: AbortSignal | undefined): Promise<GenerateRecoveryCodesResponse> {
    let url_ = this.baseUrl + "/api/v2/identity/2fa/recoveryCodes";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processGenerateRecoveryCodes(_response);
    });
  }

  protected processGenerateRecoveryCodes(response: Response): Promise<GenerateRecoveryCodesResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GenerateRecoveryCodesResponse;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<GenerateRecoveryCodesResponse>(null as any);
  }

  enable2fa(signal?: AbortSignal | undefined): Promise<Enable2faResponse> {
    let url_ = this.baseUrl + "/api/v2/identity/2fa/enable";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processEnable2fa(_response);
    });
  }

  protected processEnable2fa(response: Response): Promise<Enable2faResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Enable2faResponse;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<Enable2faResponse>(null as any);
  }

  confirm2fa(request: Confirm2faRequest, signal?: AbortSignal | undefined): Promise<TwoFactorAuthenticationResponse> {
    let url_ = this.baseUrl + "/api/v2/identity/2fa/confirm";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(request);

    let options_: RequestInit = {
      body: content_,
      method: "POST",
      signal,
      headers: {
        "Content-Type": "application/json",
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processConfirm2fa(_response);
    });
  }

  protected processConfirm2fa(response: Response): Promise<TwoFactorAuthenticationResponse> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 400) {
      return response.text().then((_responseText) => {
        let result400: any = null;
        result400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TwoFactorAuthenticationResponse;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<TwoFactorAuthenticationResponse>(null as any);
  }

  reset2fa(signal?: AbortSignal | undefined): Promise<string> {
    let url_ = this.baseUrl + "/api/v2/identity/2fa/reset";
    url_ = url_.replace(/[?&]$/, "");

    let options_: RequestInit = {
      method: "POST",
      signal,
      headers: {
        "Accept": "application/json"
      }
    };

    return this.http.fetch(url_, options_).then((_response: Response) => {
      return this.processReset2fa(_response);
    });
  }

  protected processReset2fa(response: Response): Promise<string> {
    const status = response.status;
    let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
    if (status === 401) {
      return response.text().then((_responseText) => {
        let result401: any = null;
        result401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ApiV2ErrorResponse;
        return throwException("A server side error occurred.", status, _responseText, _headers, result401);
      });
    } else if (status === 200) {
      return response.text().then((_responseText) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
        return result200;
      });
    } else if (status !== 200 && status !== 204) {
      return response.text().then((_responseText) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      });
    }
    return Promise.resolve<string>(null as any);
  }
}

export interface CheckForUpdatesResponse {
  latest_version: string;
  url: string;
  is_latest: boolean;
  must_latest: boolean;
}

export interface ApiErrorResponse {
  error_code: ApiErrorCode;
  message?: string | undefined;
  documentation_url?: string | undefined;
}

export enum ApiErrorCode {
  Unknown = 0,
  AuthenticationIsRequired = 1,
  DoNotHavePermissions = 2,
  PackageNotFound = 3,
  PackageNotFoundById = 4,
  PackageIsPrivate = 5,
  UserNotFound = 6,
  UserNotFoundById = 7,
  InvalidPackageName = 8,
  InvalidAssetName = 9,
  InvalidLocaleId = 10,
  InvalidReleaseVersion = 11,
  InvalidRefreshToken = 12,
  InvalidRequestBody = 13,
  AssetMustHaveAtLeastOneHashValue = 14,
  InvalidVersionFormat = 15,
  PackageResourceNotFound = 16,
  PackageResouceHasAlreadyBeenAdded = 17,
  ReleaseNotFound = 18,
  ReleaseNotFoundById = 19,
  CannotPublishAReleaseThatDoesNotHaveAnAsset = 20,
  ReleaseResourceNotFound = 21,
  ReleaseResourceHasAlreadyBeenAdded = 22,
  AssetNotFound = 23,
  AssetNotFoundById = 24,
  RawAssetNotFound = 25,
  NoFilesDataInTheRequest = 26,
  FileIsTooLarge = 27,
  VirtualAssetCannotBeDownloaded = 28,
  CannotDeleteReleaseAssets = 29,
}

export interface AssetMetadataResponse {
  id: number;
  name: string;
  asset_type: AssetType;
  content_type: string;
  download_url: string;
  size?: number | undefined;
  sha256?: string | undefined;
  sha384?: string | undefined;
  sha512?: string | undefined;
  public: boolean;
  created_at: Date;
  updated_at: Date;
}

export enum AssetType {
  Virtual = 0,
  Physical = 1,
}

export interface SimpleProfileResponse {
  packages_url: string;
  url: string;
  id: string;
  name: string;
  display_name: string;
  avatar_id?: number | undefined;
  avatar_url?: string | undefined;
}

export interface SimplePackageResponse {
  owner_id: string;
  id: number;
  owner_url: string;
  url: string;
  releases_url: string;
  name: string;
  display_name: string;
  description: string;
  short_description: string;
  public: boolean;
  tags: string[];
  logo_url?: string | undefined;
  created_at: Date;
  updated_at: Date;
}

export interface PackageResponse {
  id: number;
  owner: SimpleProfileResponse;
  url: string;
  releases_url: string;
  name: string;
  display_name: string;
  description: string;
  short_description: string;
  public: boolean;
  website: string;
  tags: string[];
  logo_id?: number | undefined;
  logo_url?: string | undefined;
  screenshots?: { [key: string]: string; } | undefined;
  created_at: Date;
  updated_at: Date;
}

export interface ReleaseResponse {
  owner_url: string;
  package_url: string;
  url: string;
  owner_id: string;
  package_id: number;
  id: number;
  version: string;
  title: string;
  body: string;
  target_version?: string | undefined;
  public: boolean;
  asset_id?: number | undefined;
  created_at: Date;
  updated_at: Date;
}

export interface ProfileResponse {
  packages_url: string;
  url: string;
  id: string;
  name: string;
  bio: string;
  display_name: string;
  email: string;
  twitter_username: string;
  github_username: string;
  youtube_url: string;
  blog_url: string;
  avatar_url?: string | undefined;
  avatar_id?: number | undefined;
  created_at: Date;
  updated_at: Date;
  public_packages: number;
}

export interface StorageUsageResponse {
  size: number;
  max_size: number;
  details: { [key: string]: number; };
}

export interface CreateAuthUriResponse {
  auth_uri: string;
  session_id: string;
}

export interface CreateAuthUriRequest {
  continue_uri: string;
}

export interface AuthResponse {
  token: string;
  refresh_token: string;
  expiration: Date;
}

export interface RefeshTokenRequest {
  token: string;
  refresh_token: string;
}

export interface CodeToJwtRequest {
  code: string;
  session_id: string;
}

export interface UpdateAssetRequest {
  public: boolean;
}

export interface GotPackageResponse {
  package: SimplePackageResponse;
  latest_release?: ReleaseResponse | undefined;
  latest_release_asset?: AssetMetadataResponse | undefined;
}

export interface GetPackageRequest {
  package_id: number;
}

export interface UpdatePackageRequest {
  display_name?: string | undefined;
  description?: string | undefined;
  short_description?: string | undefined;
  website?: string | undefined;
  tags?: string[] | undefined;
  public?: boolean | undefined;
  logo_image_id?: number | undefined;
  screenshots?: number[] | undefined;
}

export interface CreatePackageRequest {
  display_name: string;
  description: string;
  short_description: string;
  website: string;
  tags: string[];
}

export interface UpdateReleaseRequest {
  title?: string | undefined;
  body?: string | undefined;
  target_version?: string | undefined;
  public?: boolean | undefined;
  asset_id?: number | undefined;
}

export interface CreateReleaseRequest {
  title: string;
  body: string;
  target_version?: string | undefined;
}

/** Encapsulates an error from the identity subsystem. */
export interface IdentityError {
  /** Gets or sets the code for this error. */
  code: string;
  /** Gets or sets the description for this error. */
  description: string;
}

export interface UpdateProfileRequest {
  bio?: string | undefined;
  display_name?: string | undefined;
  twitter_username?: string | undefined;
  github_username?: string | undefined;
  youtube_url?: string | undefined;
  blog_url?: string | undefined;
  avatar_id?: number | undefined;
}

export interface ApiV2ErrorResponse {
  errorCode: ApiV2ErrorCode;
  message?: string | undefined;
  documentationUrl?: string | undefined;
  details?: ApiErrorDetail[] | undefined;
}

export enum ApiV2ErrorCode {
  Unknown = 0,
  AuthenticationIsRequired = 1,
  DoNotHavePermissions = 2,
  PackageNotFound = 3,
  PackageNotFoundById = 4,
  PackageIsPrivate = 5,
  UserNotFound = 6,
  UserNotFoundById = 7,
  InvalidPackageName = 8,
  InvalidAssetName = 9,
  InvalidLocaleId = 10,
  InvalidReleaseVersion = 11,
  InvalidRefreshToken = 12,
  InvalidRequestBody = 13,
  AssetMustHaveAtLeastOneHashValue = 14,
  InvalidVersionFormat = 15,
  PackageResourceNotFound = 16,
  PackageResouceHasAlreadyBeenAdded = 17,
  ReleaseNotFound = 18,
  ReleaseNotFoundById = 19,
  CannotPublishAReleaseThatDoesNotHaveAnAsset = 20,
  ReleaseResourceNotFound = 21,
  ReleaseResourceHasAlreadyBeenAdded = 22,
  AssetNotFound = 23,
  AssetNotFoundById = 24,
  RawAssetNotFound = 25,
  NoFilesDataInTheRequest = 26,
  FileIsTooLarge = 27,
  VirtualAssetCannotBeDownloaded = 28,
  CannotDeleteReleaseAssets = 29,
  MultipleErrors = 30,
  UserAccountLockedOut = 31,
  InvalidSignInAttempt = 32,
  UnableToLoad2faUser = 33,
  InvalidAuthenticatorCode = 34,
  InvalidRecoveryCodeEntered = 35,
  ErrorLoadingExternalLoginInformation = 36,
  ErrorLoadingExternalLoginInformationDuringConfirmation = 37,
  EmailIsMissingFromExternalLoginInformation = 38,
  TwoFactorRequired = 39,
  ErrorConfirmingEmail = 40,
  ErrorChangingEmail = 41,
  ExternalLoginWasNotRemoved = 42,
  ExternalLoginWasNotAdded = 43,
  RequirePassword = 44,
  IncorrectPassword = 45,
  VerificationCodeIsInvalid = 46,
  SiteVerificationFailed = 47,
}

export interface ApiErrorDetail {
  field: string;
  message: string;
}

export interface Fido2ResponseBase {
  status?: string | undefined;
  errorMessage?: string | undefined;
}

export interface CredentialCreateOptions extends Fido2ResponseBase {
  rp?: PublicKeyCredentialRpEntity | undefined;
  user?: Fido2User | undefined;
  challenge?: string | undefined;
  pubKeyCredParams?: PubKeyCredParam[] | undefined;
  timeout: number;
  attestation: AttestationConveyancePreference;
  authenticatorSelection?: AuthenticatorSelection | undefined;
  excludeCredentials?: PublicKeyCredentialDescriptor[] | undefined;
  extensions?: AuthenticationExtensionsClientInputs | undefined;
}

export interface PublicKeyCredentialRpEntity {
  id: string;
  name: string;
  icon?: string | undefined;
}

export interface Fido2User {
  name?: string | undefined;
  id?: string | undefined;
  displayName?: string | undefined;
}

export interface PubKeyCredParam {
  type: PublicKeyCredentialType;
  alg: Algorithm;
}

export enum PublicKeyCredentialType {
  PublicKey = 0,
  Invalid = 1,
}

export enum Algorithm {
  RS1 = -65535,
  RS512 = -259,
  RS384 = -258,
  RS256 = -257,
  ES256K = -47,
  PS512 = -39,
  PS384 = -38,
  PS256 = -37,
  ES512 = -36,
  ES384 = -35,
  EdDSA = -8,
  ES256 = -7,
}

export enum AttestationConveyancePreference {
  None = 0,
  Indirect = 1,
  Direct = 2,
  Enterprise = 3,
}

export interface AuthenticatorSelection {
  authenticatorAttachment?: AuthenticatorAttachment | undefined;
  residentKey: ResidentKeyRequirement;
  requireResidentKey: boolean;
  userVerification: UserVerificationRequirement;
  default?: AuthenticatorSelection | undefined;
}

export enum AuthenticatorAttachment {
  Platform = 0,
  CrossPlatform = 1,
}

export enum ResidentKeyRequirement {
  Required = 0,
  Preferred = 1,
  Discouraged = 2,
}

export enum UserVerificationRequirement {
  Required = 0,
  Preferred = 1,
  Discouraged = 2,
}

export interface PublicKeyCredentialDescriptor {
  type: PublicKeyCredentialType;
  id: string;
  transports?: AuthenticatorTransport[] | undefined;
}

export enum AuthenticatorTransport {
  Usb = 0,
  Nfc = 1,
  Ble = 2,
  Internal = 3,
}

export interface AuthenticationExtensionsClientInputs {
  "example.extension.bool"?: any | undefined;
  appid?: string | undefined;
  authnSel?: string[] | undefined;
  exts?: boolean | undefined;
  uvm?: boolean | undefined;
  devicePubKey?: AuthenticationExtensionsDevicePublicKeyInputs | undefined;
  credProps?: boolean | undefined;
  prf?: AuthenticationExtensionsPRFInputs | undefined;
}

export interface AuthenticationExtensionsDevicePublicKeyInputs {
  attestation?: string | undefined;
  attestationFormats?: string[] | undefined;
}

export interface AuthenticationExtensionsPRFInputs {
  eval?: AuthenticationExtensionsPRFValues | undefined;
  evalByCredential?: KeyValuePairOfStringAndAuthenticationExtensionsPRFValues | undefined;
}

export interface AuthenticationExtensionsPRFValues {
  first?: string | undefined;
  second?: string | undefined;
}

export interface KeyValuePairOfStringAndAuthenticationExtensionsPRFValues {
  key?: string | undefined;
  value?: AuthenticationExtensionsPRFValues | undefined;
}

export interface CredentialMakeResult extends Fido2ResponseBase {
  result?: RegisteredPublicKeyCredential | undefined;
}

export interface RegisteredPublicKeyCredential extends Fido2ResponseBase {
  type: PublicKeyCredentialType;
  id?: string | undefined;
  publicKey?: string | undefined;
  transports?: AuthenticatorTransport[] | undefined;
  signCount: number;
  isBackupEligible: boolean;
  isBackedUp: boolean;
  devicePublicKey?: string | undefined;
  aaGuid: string;
  user?: Fido2User | undefined;
  attestationFormat?: string | undefined;
  attestationObject?: string | undefined;
  attestationClientDataJson?: string | undefined;
}

export interface AuthenticatorAttestationRawResponse {
  id?: string | undefined;
  rawId?: string | undefined;
  type: PublicKeyCredentialType;
  response?: ResponseData | undefined;
  extensions?: AuthenticationExtensionsClientOutputs | undefined;
}

export interface ResponseData {
  attestationObject?: string | undefined;
  clientDataJSON?: string | undefined;
}

export interface AuthenticationExtensionsClientOutputs {
  "example.extension.bool"?: any | undefined;
  appid: boolean;
  authnSel: boolean;
  exts?: string[] | undefined;
  uvm?: number[][] | undefined;
  devicePubKey?: AuthenticationExtensionsDevicePublicKeyOutputs | undefined;
  credProps?: CredentialPropertiesOutput | undefined;
  prf?: AuthenticationExtensionsPRFOutputs | undefined;
}

export interface AuthenticationExtensionsDevicePublicKeyOutputs {
  authenticatorOutput: string;
  signature: string;
}

export interface CredentialPropertiesOutput {
  rk: boolean;
}

export interface AuthenticationExtensionsPRFOutputs {
  enabled: boolean;
  results?: AuthenticationExtensionsPRFValues | undefined;
}

export interface AssertionOptions extends Fido2ResponseBase {
  challenge?: string | undefined;
  timeout: number;
  rpId?: string | undefined;
  allowCredentials?: PublicKeyCredentialDescriptor[] | undefined;
  userVerification?: UserVerificationRequirement | undefined;
  extensions?: AuthenticationExtensionsClientInputs | undefined;
}

export interface VerifyAssertionResult extends Fido2ResponseBase {
  credentialId?: string | undefined;
  signCount: number;
  isBackedUp: boolean;
  devicePublicKey?: string | undefined;
}

export interface AuthenticatorAssertionRawResponse {
  id?: string | undefined;
  rawId?: string | undefined;
  response?: AssertionResponse | undefined;
  type?: PublicKeyCredentialType | undefined;
  extensions?: AuthenticationExtensionsClientOutputs | undefined;
}

export interface AssertionResponse {
  authenticatorData?: string | undefined;
  signature?: string | undefined;
  clientDataJSON?: string | undefined;
  userHandle?: string | undefined;
  attestationObject?: string | undefined;
}

export interface Fido2CredentialResponse {
  displayName: string;
  id: string;
  addedAt: Date;
  lastUsedDate: Date;
}

export interface UpdateFido2CredentialRequest {
  displayName?: string | undefined;
}

export interface SignInRequest {
  email: string;
  password: string;
  rememberMe: boolean;
}

export interface SignInWith2faRequest {
  twoFactorCode: string;
  rememberMachine: boolean;
}

export interface SignInWithRecoveryCodeRequest {
  recoveryCode: string;
}

export interface SignInWithResponse {
  status: SignInWithStatusCode;
  message: string;
  addtional?: string | undefined;
}

export enum SignInWithStatusCode {
  Success = 0,
  ConfirmEmail = 1,
}

export interface SignInWithConfirmationRequest {
  email: string;
}

export interface SignUpRequest {
  email: string;
  password: string;
  rememberMe: boolean;
  siteVerifyToken: string;
}

export interface CheckEmailResponse {
  suceeded: boolean;
}

export interface CheckEmailRequest {
  email: string;
}

export interface ConfirmEmailRequest {
  userId: string;
  code: string;
}

export interface ConfirmEmailChangeRequest {
  userId: string;
  email: string;
  code: string;
}

export interface IsAuthenticatedResponse {
  isAuthenticated: boolean;
}

export interface IdentityResponse {
  email: string;
  id: string;
  userName: string;
  displayName: string;
  roles: string[];
  emailConfirmed: boolean;
}

export interface UpdateUserNameRequest {
  newUserName: string;
}

export interface UpdateEmailRequest {
  newEmail: string;
}

export interface ForgotPasswordRequest {
  email: string;
}

export interface ResetPasswordRequest {
  email: string;
  password: string;
  code: string;
}

export interface SetPasswordRequest {
  password: string;
}

export interface ChangePasswordRequest {
  oldPassword: string;
  newPassword: string;
}

export interface ExternalAccountsResponse {
  currentAccounts: ExternalAccountProvider[];
  otherAccounts: ExternalAccountProvider[];
}

export interface ExternalAccountProvider {
  name: string;
  display?: string | undefined;
}

export interface RemoveExternalAccountResponse {
  removedAccount: ExternalAccountProvider;
  message: string;
}

export interface LinkExternalAccountResponse {
  linkedAccount: ExternalAccountProvider;
  message: string;
}

export interface DeleteAccountResponse {
  suceeded: boolean;
}

export interface DeleteAccountRequest {
  password?: string | undefined;
  siteVerifyToken: string;
}

export interface TwoFactorAuthenticationResponse {
  hasAuthenticator: boolean;
  is2faEnabled: boolean;
  isMachineRemembered: boolean;
  recoveryCodesLeft: number;
}

export interface GenerateRecoveryCodesResponse {
  recoveryCodes: string[];
}

export interface Enable2faResponse {
  sharedKey: string;
  authenticatorUri: string;
}

export interface Confirm2faRequest {
  code: string;
}

export interface FileParameter {
  data: any;
  fileName: string;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any; };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
  throw new ApiException(message, status, response, headers, result);
}